{"version":3,"sources":["../../../projects/ngx-gauge/src/common/util.ts","../../../projects/ngx-gauge/src/gauge/gauge-directives.ts","../../../projects/ngx-gauge/src/gauge/gauge.ts","../../../projects/ngx-gauge/src/ngx-gauge.module.ts"],"names":["coerceNumberProperty","value","fallbackValue","isNaN","parseFloat","Number","cssUnit","Directive","args","selector","exportAs","DEFAULTS","NgxGauge","_elementRef","_renderer","this","_size","_min","_max","_animate","_initialized","_animationRequestID","ariaLabel","ariaLabelledby","type","cap","thick","shadowColor","foregroundColor","backgroundColor","thresholds","Object","create","preserveThresholds","thumb","_value","duration","defineProperty","prototype","coerceBooleanProperty","val","ngOnChanges","changes","isCanvasPropertyChanged","isDataChanged","nv","ov","currentValue","previousValue","_update","_destroy","_init","_updateSize","setStyle","nativeElement","_getWidth","_getCanvasHeight","_canvas","width","height","_label","size","_reading","ngAfterViewInit","ngOnDestroy","_getBounds","head","tail","Math","PI","_drawShell","start","middle","color","_drawShellWithSegments","center","_getCenter","radius","_getRadius","max","min","_clear","_context","beginPath","strokeStyle","arc","x","y","stroke","percentages","keys","arcLength","valuePercent","thumbColor","i","length","startPercentage","nextPercentage","percentageToTravel","fallbackColor","percentageOfCurrentArc","activeArcEnd","_drawArc","_drawArcShadow","inactiveArcEnd","arcColor","end","_drawThumb","cos","sin","_getHeight","fillStyle","fill","lineWidth","clearRect","getContext","_setupStyles","_create","window","cancelAnimationFrame","lineCap","_getForegroundColorByRange","match","filter","item","undefined","isNumber","sort","a","b","reverse","startTime","self","bounds","clamp","unit","displacement","animate","timestamp","runtime","Date","getTime","progress","requestAnimationFrame","Component","template","host","role","aria-readonly","[class.ngx-gauge-meter]","[attr.aria-valuemin]","[attr.aria-valuemax]","[attr.aria-valuenow]","[attr.aria-label]","[attr.aria-labelledby]","encapsulation","ViewEncapsulation","None","ElementRef","Renderer2","ViewChild","static","ContentChild","NgxGaugeLabel","NgxGaugePrepend","NgxGaugeAppend","NgxGaugeValue","Input","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["export function clamp(value: number, min: number, max: number): number {\r\n    return Math.max(min, Math.min(max, value));\r\n}\r\nexport function coerceBooleanProperty(value: any): boolean {\r\n    return value != null && `${value}` !== 'false';\r\n}\r\nexport function coerceNumberProperty(value: any, fallbackValue: number = 0): number {\r\n    return isNaN(parseFloat(value)) || isNaN(Number(value)) ? fallbackValue : Number(value);\r\n}\r\nexport function cssUnit(value: number) {\r\n    return `${value}px`;\r\n}\r\nexport function isNumber(value: string) {\r\n    return value != undefined && !isNaN(parseFloat(value)) && !isNaN(Number(value));\r\n}","import { Directive } from \"@angular/core\";\r\n\r\n@Directive({\r\n  selector: \"ngx-gauge-append\",\r\n  exportAs: \"ngxGaugeAppend\"\r\n})\r\nexport class NgxGaugeAppend {}\r\n\r\n@Directive({\r\n  selector: \"ngx-gauge-prepend\",\r\n  exportAs: \"ngxGaugePrepend\"\r\n})\r\nexport class NgxGaugePrepend {}\r\n\r\n@Directive({\r\n  selector: \"ngx-gauge-value\",\r\n  exportAs: \"ngxGaugeValue\"\r\n})\r\nexport class NgxGaugeValue {}\r\n\r\n@Directive({\r\n  selector: \"ngx-gauge-label\",\r\n  exportAs: \"ngxGaugeLabel\"\r\n})\r\nexport class NgxGaugeLabel {}\r\n","import {\r\n  Component,\r\n  Input,\r\n  SimpleChanges,\r\n  ViewEncapsulation,\r\n  Renderer2,\r\n  AfterViewInit,\r\n  ElementRef,\r\n  OnChanges,\r\n  OnDestroy,\r\n  ViewChild,\r\n  ContentChild\r\n} from '@angular/core';\r\nimport { NgxGaugeError } from './gauge-error';\r\nimport {\r\n  clamp,\r\n  coerceBooleanProperty,\r\n  coerceNumberProperty,\r\n  cssUnit,\r\n  isNumber\r\n} from '../common/util';\r\nimport { NgxGaugeLabel, NgxGaugeValue, NgxGaugePrepend, NgxGaugeAppend } from './gauge-directives';\r\n\r\nconst DEFAULTS = {\r\n  MIN: 0,\r\n  MAX: 100,\r\n  TYPE: 'arch',\r\n  THICK: 4,\r\n  FOREGROUND_COLOR: 'rgba(0, 150, 136, 1)',\r\n  BACKGROUND_COLOR: 'rgba(0, 0, 0, 0.1)',\r\n  CAP: 'butt',\r\n  SIZE: 200\r\n};\r\n\r\nexport type NgxGaugeType = 'full' | 'arch' | 'semi';\r\nexport type NgxGaugeCap = 'round' | 'butt';\r\n\r\n@Component({\r\n  selector: 'ngx-gauge',\r\n  templateUrl: 'gauge.html',\r\n  styleUrls: ['gauge.css'],\r\n  host: {\r\n    'role': 'slider',\r\n    'aria-readonly': 'true',\r\n    '[class.ngx-gauge-meter]': 'true',\r\n    '[attr.aria-valuemin]': 'min',\r\n    '[attr.aria-valuemax]': 'max',\r\n    '[attr.aria-valuenow]': 'value',\r\n    '[attr.aria-label]': 'ariaLabel',\r\n    '[attr.aria-labelledby]': 'ariaLabelledby'\r\n\r\n  },\r\n  encapsulation: ViewEncapsulation.None\r\n})\r\nexport class NgxGauge implements AfterViewInit, OnChanges, OnDestroy {\r\n\r\n  @ViewChild('canvas', { static: true }) _canvas: ElementRef;\r\n  @ViewChild('rLabel', { static: true }) _label: ElementRef;\r\n  @ViewChild('reading', { static: true }) _reading: ElementRef;\r\n\r\n  @ContentChild(NgxGaugeLabel) _labelChild: NgxGaugeLabel;\r\n  @ContentChild(NgxGaugePrepend) _prependChild: NgxGaugePrepend;\r\n  @ContentChild(NgxGaugeAppend) _appendChild: NgxGaugeAppend;\r\n  @ContentChild(NgxGaugeValue) _valueDisplayChild: NgxGaugeValue;\r\n\r\n  private _size: number = DEFAULTS.SIZE;\r\n  private _min: number = DEFAULTS.MIN;\r\n  private _max: number = DEFAULTS.MAX;\r\n  private _animate: boolean = true;\r\n\r\n  private _initialized: boolean = false;\r\n  private _context: CanvasRenderingContext2D;\r\n  private _animationRequestID: number = 0;\r\n\r\n  @Input('aria-label') ariaLabel: string = '';\r\n\r\n  @Input('aria-labelledby') ariaLabelledby: string | null = null;\r\n\r\n  @Input()\r\n  get size(): number { return this._size; }\r\n  set size(value: number) {\r\n    this._size = coerceNumberProperty(value);\r\n  }\r\n\r\n  @Input()\r\n  get min(): number { return this._min; }\r\n  set min(value: number) {\r\n    this._min = coerceNumberProperty(value, DEFAULTS.MIN);\r\n  }\r\n  @Input()\r\n  get animate(): boolean { return this._animate; }\r\n  set animate(value) {\r\n    this._animate = coerceBooleanProperty(value);\r\n  }\r\n\r\n  @Input()\r\n  get max(): number { return this._max; }\r\n  set max(value: number) {\r\n    this._max = coerceNumberProperty(value, DEFAULTS.MAX);\r\n  }\r\n\r\n  @Input() type: NgxGaugeType = DEFAULTS.TYPE as NgxGaugeType;\r\n\r\n  @Input() cap: NgxGaugeCap = DEFAULTS.CAP as NgxGaugeCap;\r\n\r\n  @Input() thick: number = DEFAULTS.THICK;\r\n\r\n  @Input() label: string;\r\n\r\n  @Input() append: string;\r\n\r\n  @Input() prepend: string;\r\n\r\n  @Input() shadowColor: string = '';\r\n\r\n  @Input() foregroundColor: string = DEFAULTS.FOREGROUND_COLOR;\r\n\r\n  @Input() backgroundColor: string = DEFAULTS.BACKGROUND_COLOR;\r\n\r\n  @Input() thresholds: Object = Object.create(null);\r\n\r\n  // If set to true, thresholds will remain their color even if the gauge is in another threshold\r\n  @Input() preserveThresholds: Object = false;\r\n\r\n  @Input() thumb: Object = false;\r\n\r\n  private _value: number = 0;\r\n\r\n  @Input()\r\n  get value() { return this._value; }\r\n  set value(val: number) {\r\n    this._value = coerceNumberProperty(val);\r\n  }\r\n\r\n  @Input() duration: number = 1200;\r\n\r\n  constructor(private _elementRef: ElementRef, private _renderer: Renderer2) { }\r\n\r\n  ngOnChanges(changes: SimpleChanges) {\r\n    const isCanvasPropertyChanged = changes['thick'] || changes['type'] || changes['cap'] || changes['size'];\r\n    const isDataChanged = changes['value'] || changes['min'] || changes['max'];\r\n\r\n    if (this._initialized) {\r\n      if (isDataChanged) {\r\n        let nv, ov;\r\n        if (changes['value']) {\r\n          nv = changes['value'].currentValue;\r\n          ov = changes['value'].previousValue;\r\n        }\r\n        this._update(nv, ov);\r\n      }\r\n      if (isCanvasPropertyChanged) {\r\n        this._destroy();\r\n        this._init();\r\n      }\r\n    }\r\n  }\r\n\r\n  private _updateSize() {\r\n    this._renderer.setStyle(this._elementRef.nativeElement, 'width', cssUnit(this._getWidth()));\r\n    this._renderer.setStyle(this._elementRef.nativeElement, 'height', cssUnit(this._getCanvasHeight()));\r\n    this._canvas.nativeElement.width = this._getWidth();\r\n    this._canvas.nativeElement.height = this._getCanvasHeight();\r\n    this._renderer.setStyle(this._label.nativeElement,\r\n      'transform', 'translateY(' + (this.size / 3 * 2 - this.size / 13 / 4) + 'px)');\r\n    this._renderer.setStyle(this._reading.nativeElement,\r\n      'transform', 'translateY(' + (this.size / 2 - this.size * 0.22 / 2) + 'px)');\r\n  }\r\n\r\n  ngAfterViewInit() {\r\n    if (this._canvas) {\r\n      this._init();\r\n    }\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._destroy();\r\n  }\r\n\r\n  private _getBounds(type: NgxGaugeType) {\r\n    let head, tail;\r\n    if (type == 'semi') {\r\n      head = Math.PI;\r\n      tail = 2 * Math.PI;\r\n    } else if (type == 'full') {\r\n      head = 1.5 * Math.PI;\r\n      tail = 3.5 * Math.PI;\r\n    } else if (type === 'arch') {\r\n      head = 0.8 * Math.PI;\r\n      tail = 2.2 * Math.PI;\r\n    }\r\n    return { head, tail };\r\n  }\r\n\r\n  private _drawShell(start: number, middle: number, tail: number, color: string) {\r\n    if (this.preserveThresholds) {\r\n      this._drawShellWithSegments(start, middle, tail);\r\n      return;\r\n    }\r\n\r\n    let center = this._getCenter(),\r\n      radius = this._getRadius();\r\n\r\n    middle = Math.max(middle, start); // never below 0%\r\n    middle = Math.min(middle, tail); // never exceed 100%\r\n    if (this._initialized) {\r\n      this._clear();\r\n      this._context.beginPath();\r\n      this._context.strokeStyle = this.backgroundColor;\r\n      this._context.arc(center.x, center.y, radius, middle, tail, false);\r\n      this._context.stroke();\r\n\r\n      this._context.beginPath();\r\n      this._context.strokeStyle = color;\r\n      this._context.arc(center.x, center.y, radius, start, middle, false);\r\n      this._context.stroke();\r\n    }\r\n  }\r\n\r\n  private _drawShellWithSegments(start: number, currentValue: number, tail: number) {\r\n    if (this.thresholds && this._initialized) {\r\n      let percentages = Object.keys(this.thresholds),\r\n        arcLength = tail - start,\r\n        valuePercent = (currentValue - start) / arcLength;\r\n\r\n      this._clear();\r\n      let thumbColor = this.backgroundColor;\r\n      for (let i = 0; i < percentages.length; i++) {\r\n        let startPercentage = (Number(percentages[i]) / 100),\r\n          nextPercentage = (Number(percentages[i + 1]) / 100) || 1,\r\n          percentageToTravel = (nextPercentage - startPercentage),\r\n          color = this.thresholds[percentages[i]].color,\r\n          fallbackColor = this.thresholds[percentages[i]].fallbackColor || this.backgroundColor;\r\n\r\n        if (valuePercent >= startPercentage && valuePercent <= nextPercentage) {\r\n          let percentageOfCurrentArc = (valuePercent - startPercentage) / percentageToTravel;\r\n          let activeArcEnd = start + (arcLength * percentageToTravel * percentageOfCurrentArc);\r\n          thumbColor = color\r\n          this._drawArc(start, activeArcEnd, color);\r\n          if (this.shadowColor) {\r\n            this._drawArcShadow(start, activeArcEnd, this.shadowColor);\r\n          }\r\n\r\n          let inactiveArcEnd = activeArcEnd + (arcLength * percentageToTravel * (1 - percentageOfCurrentArc));\r\n          this._drawArc(activeArcEnd, inactiveArcEnd, fallbackColor);\r\n          if (this.shadowColor) {\r\n            this._drawArcShadow(activeArcEnd, inactiveArcEnd, this.shadowColor);\r\n          }\r\n\r\n          start = inactiveArcEnd;\r\n        } else {\r\n          let arcColor = (startPercentage >= valuePercent) ? fallbackColor : color;\r\n          let end = start + (arcLength * percentageToTravel);\r\n          this._drawArc(start, end, arcColor);\r\n          if (this.shadowColor) {\r\n            this._drawArcShadow(start, end, this.shadowColor);\r\n          }\r\n\r\n          start = end;\r\n        }\r\n      }\r\n\r\n      if (this.thumb) {\r\n        this._drawThumb(currentValue, thumbColor);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _drawArc(start: number, end: number, color: string) {\r\n    let center = this._getCenter();\r\n    let radius = this._getRadius();\r\n    this._context.beginPath();\r\n    this._context.strokeStyle = color;\r\n    this._context.arc(center.x, center.y, radius, start, end, false);\r\n    this._context.stroke();\r\n  }\r\n  private _drawArcShadow(start: number, end: number, color: string) {\r\n    let center = this._getCenter();\r\n    let radius = this._getRadius() * 0.89;\r\n    this._context.beginPath();\r\n    this._context.strokeStyle = color;\r\n    this._context.arc(center.x, center.y, radius, start, end, false);\r\n    this._context.stroke();\r\n  }\r\n\r\n  private _drawThumb(valuePercent, color: string) {\r\n    let radius = this.thick * 0.8;\r\n\r\n    let x = (this._getRadius() * Math.cos(valuePercent)) + (this._getWidth() / 2)\r\n    let y = (this._getRadius() * Math.sin(valuePercent)) + (this._getHeight() / 2)\r\n\r\n    this._context.beginPath();\r\n    this._context.arc(x, y, radius, 0, 2 * Math.PI, false);\r\n    this._context.fillStyle = \"#fff\";\r\n    this._context.fill();\r\n    this._context.lineWidth = this.thick / 3;\r\n    this._context.strokeStyle = color;\r\n    this._context.stroke();\r\n    this._context.lineWidth = this.thick\r\n  }\r\n\r\n  private _clear() {\r\n    this._context.clearRect(0, 0, this._getWidth(), this._getHeight());\r\n  }\r\n\r\n  private _getWidth() {\r\n    return this.size;\r\n  }\r\n\r\n  private _getHeight() {\r\n    return this.size;\r\n  }\r\n\r\n  // canvas height will be shorter for type 'semi' and 'arch'\r\n  private _getCanvasHeight() {\r\n    return (this.type == 'arch' || this.type == 'semi')\r\n      ? 0.85 * this._getHeight()\r\n      : this._getHeight();\r\n  }\r\n\r\n  private _getRadius() {\r\n    var center = this._getCenter();\r\n    return center.x - this.thick;\r\n  }\r\n\r\n  private _getCenter() {\r\n    var x = this._getWidth() / 2,\r\n      y = this._getHeight() / 2;\r\n    return { x, y };\r\n  }\r\n\r\n  private _init() {\r\n    this._context = (this._canvas.nativeElement as HTMLCanvasElement).getContext('2d');\r\n    this._initialized = true;\r\n    this._updateSize();\r\n    this._setupStyles();\r\n    this._create();\r\n  }\r\n\r\n  private _destroy() {\r\n    if (this._animationRequestID) {\r\n      window.cancelAnimationFrame(this._animationRequestID);\r\n      this._animationRequestID = 0;\r\n    }\r\n    this._clear();\r\n    this._context = null;\r\n    this._initialized = false;\r\n  }\r\n\r\n  private _setupStyles() {\r\n    this._context.lineCap = this.cap;\r\n    this._context.lineWidth = this.thick;\r\n  }\r\n\r\n  private _getForegroundColorByRange(value) {\r\n\r\n    const match = Object.keys(this.thresholds)\r\n      .filter(function (item) { return isNumber(item) && Number(item) <= value })\r\n      .sort((a, b) => Number(a) - Number(b))\r\n      .reverse()[0];\r\n\r\n    return match !== undefined\r\n      ? this.thresholds[match].color || this.foregroundColor\r\n      : this.foregroundColor;\r\n  }\r\n\r\n  private _create(nv?: number, ov?: number) {\r\n    let self = this,\r\n      type = this.type,\r\n      bounds = this._getBounds(type),\r\n      duration = this.duration,\r\n      min = this.min,\r\n      max = this.max,\r\n      value = clamp(this.value, this.min, this.max),\r\n      start = bounds.head,\r\n      unit = (bounds.tail - bounds.head) / (max - min),\r\n      displacement = unit * (value - min),\r\n      tail = bounds.tail,\r\n      color = this._getForegroundColorByRange(value),\r\n      startTime;\r\n\r\n    if (self._animationRequestID) {\r\n      window.cancelAnimationFrame(self._animationRequestID);\r\n    }\r\n\r\n    function animate(timestamp) {\r\n      timestamp = timestamp || new Date().getTime();\r\n      let runtime = timestamp - startTime;\r\n      let progress = Math.min(runtime / duration, 1);\r\n      let previousProgress = ov ? (ov - min) * unit : 0;\r\n      let middle = start + previousProgress + displacement * progress;\r\n\r\n      self._drawShell(start, middle, tail, color);\r\n      if (self._animationRequestID && (runtime < duration)) {\r\n        self._animationRequestID = window.requestAnimationFrame((timestamp) => animate(timestamp));\r\n      } else {\r\n        window.cancelAnimationFrame(self._animationRequestID);\r\n      }\r\n    }\r\n    if (this._animate) {\r\n      if (nv != undefined && ov != undefined) {\r\n        displacement = unit * nv - unit * ov;\r\n      }\r\n      self._animationRequestID = window.requestAnimationFrame((timestamp) => {\r\n        startTime = timestamp || new Date().getTime();\r\n        animate(startTime);\r\n      });\r\n    } else {\r\n      self._drawShell(start, start + displacement, tail, color);\r\n    }\r\n  }\r\n\r\n  private _update(nv: number, ov: number) {\r\n    this._clear();\r\n    this._create(nv, ov);\r\n  }\r\n\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { NgxGauge } from './gauge/gauge';\r\nimport { NgxGaugeLabel, NgxGaugeValue, NgxGaugePrepend, NgxGaugeAppend } from './gauge/gauge-directives';\r\n\r\n@NgModule({\r\n  imports: [CommonModule],\r\n  declarations: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel],\r\n  exports: [NgxGauge, NgxGaugeAppend, NgxGaugePrepend, NgxGaugeValue, NgxGaugeLabel]\r\n})\r\nexport class NgxGaugeModule { }"]}